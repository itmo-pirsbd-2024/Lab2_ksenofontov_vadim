# Лабораторная работа № 1

## Раздел
Профилирование и тестирование производительности

## Описание
В данной лабораторной работе студентам предстоит реализовать один из изученных на предыдущих курсах алгоритмов или структур данных и выполнить анализ производительности полученного решения, а также серию оптимизаций алгоритма с точки зрения потребления памяти, ресурсов процессора и jit-а.

## Рассматриваемые алгоритмы
В рамках работы были реализованы и проанализированы следующие алгоритмы сортировок на основе сравнений:
- сортировка пузырьком;
- сортировка слиянием;
- рекурсивная быстрая сортировка;
- итеративная быстрая сортировка;
- встроенная сортировка. 

## Принцип качественного и количественного тестирования
Каждая реализация сортировки в первую очередь подвергалась качественному тестированию - проверялся факт того, что массив после применения к нему сортировки является отсортированным. Для этого с помощью Junit был создан класс ``SortCorrectnessTest``. Количественная оценка производительности реализаций состояла в замере с помощью JMH среднего времени работы реализаций на массивах целых чисел, размер которых начинается с **1000** элементов, и, удваиваясь, доходит до **128000**.

Массивы для тестов генерировались случайно. Воспроизводимость тестов обеспечивалась установкой исходного значения для генератора псевдослучайных чисел. После каждого вызова сортирующего алгоритма отсортированный массив необходимо откатить в исходное, неотсортированное состояние. Решение этой задачи не может быть реализовано в секции ```Setup```, так как методы этой секции вызываются в начале итерации, а откат массива должен осуществляться после каждого запуска, которых в итерации неопределенное количество. 

Откат массива реализовывался путем восстанавления из его предварительно сохраненной копии. Можно обойтись без создания копии, пересоздавая массив из последовательности псевдослучайных чисел, генерируемой по тому же исходному значению, что и исходный массив. Как первый, так и второй способы предполагают откат массива внутри самих запусков-измерений, что потенциально может повлиять на результаты. Несмотря на это, с учетом того, что откат массива выполняется за линейное время, а сортировки - минимум за линейно-логарифмическое, существенного влияния на результаты измерений откат не окажет.

Для предотвращения удаления компилятором фрагментов кода, не создающих побочных эффектов, изменяющиеся переменные были помещены в ```blackhole```.

## Профили CPU и аллокаций
Для проверки выдвинутых в отношении каждого алгоритма гипотез с помощью async-profiler были собраны их профили по использованию CPU и выделениям памяти. Сэмплирование осуществлялось с шагом в 100 наносекунд.

## Сортировка пузырьком
### Реализация
В реализации нет деталей, стоящих пояснения, был реализован алгоритм перебора, совершающий $`n^2`$ сравнений.

### Гипотезы
- с учетом реализации алгоритма ожидается квадратичный рост времени выполнения сортировки при линейном росте объема сортируемых данных;
- простота и низкоуровневость операций алгоритма позволяет ожидать минимального количества вызовов различных методов при его работе;
- выполнение сортировки in-place позволяет ожидать того, что граф аллокаций будет пустым.

### Время работы
Результаты запуска бенчмарка JMH:

Data size | 1000 | 2000 | 4000 | 8000 | 16000 | 32000 | 64000 | 128000
--- | --- | --- | --- |--- |--- |--- |--- |---
Run duration, ms | 1,462 | 6,093 | 22,908 | 111,334 | 10⁻⁶ | 10⁻⁶ | 10⁻⁶ | 10⁻⁶
Error, ms | ± 0,094 | ± 0,497 | ± 1,490 | ± 9,739 |  |  |  | 

Как видно из замеров, при удвоении размера исходного массива время работы с ним алгоритма в среднем учетверяется, что на практике подтверждает гипотезу о квадратичном времени работы сортировки пузырьком. С учетом квадратичного роста времени выполнения алгоритма, он не запускался для массивов, содержащих более 10000 элементов.

### CPU flamegraph
Профиль CPU для пузырьковой сортировки:

| ![image](https://github.com/user-attachments/assets/1f0b0eb3-e8d9-49cc-9897-b5b46ab54283) |
|-|

Как и ожидалось, значимых вызовов при работе алгоритма не происходит, так как внутри него происходят только сравнения и обмены значениями. 

### Allocation flamegraph
Профиль аллокаций для пузырьковой сортировки:

| ![image](https://github.com/user-attachments/assets/42bb5123-8645-4ddb-91a4-fbc9dd6ad052) |
|-|

Как и ожидалось, при работе алгоритма не происходит заметных выделений памяти. 


## Сортировка слиянием
### Реализация
Была создана реализация на основе стандартного рекурсивного алгоритма, дробящего полученный массив пополам, сортирующего по отдельности каждую половину и осуществляющего слияние половин. Вычислительная сложность алгоритма определяется как $`O(n * log n)`$. Для процедуры слияния необходимо выделение доплнительного массива, хранящего соединяемые половины массива.

### Гипотезы
- с учетом реализации алгоритма ожидается линейно-логарифмический рост времени выполнения сортировки при линейном росте объема сортируемых данных;
- рекурсивная реализация алгоритма позволяет ожидать большого количества вызовов ```MergeSortImpl``` на стеке, которые можно будет увидеть на CPU профиле;
- выделение дополнительной памяти для массива с объемом, равным суммарному объему объединяемых половин массива, при каждом вызове ```MergeSubArrays``` позволяет ожидать отображения этих выделений на профиле аллокаций.

### Время работы
Результаты запуска бенчмарка JMH:

Data size | 1000 | 2000 | 4000 | 8000 | 16000 | 32000 | 64000 | 128000
--- | --- | --- | --- |--- |--- |--- |--- |---
Run duration, ms | 0,073 | 0,220 | 0,511 | 1,007 | 2,237 | 4,815 | 10,294 | 21,562
Error, ms | ± 0,008 | ± 0,015 | ± 0,128 | ± 0,077 | ± 0,091 | ± 0,374 | ± 0,571 | ± 0,986

Как видно из замеров, при удвоении размера исходного массива время работы с ним алгоритма в среднем удваивается. Логарифмическая составляющая сильнее заметна для массивов малого объема, поскольку на реальных данных, в отличие от теоретических моделей, логарифм принимает конкретное значение, являющееся очень малым по сравнению с линейной составляющей. Результаты замеров времени работы алгоритма на практике подтверждают гипотезу о линейно-логарифмичесом времени работы сортировки слиянием.

### CPU flamegraph
Профиль CPU для сортировки слиянием:

| ![image](https://github.com/user-attachments/assets/0b4929c9-ce4b-462b-8a6d-2d554300a46a) |
|-|

Как и ожидалось, на профиле вызовов при работе алгоритма отображаются рекурсивные вызовы метода ```MergeSortImpl```. Одноуровневые в контексте рекурсии вызовы при семплировании отображаются как один. После сортировки подмассивов заметен вызов метода слияния ```MergeSubArrays```. Видно, что в профиле отображается 17 рекурсивных вызовов ```MergeSortImpl```. Такая глубина соответствует логарифму по основанию 2 от размера массива.

### Allocation flamegraph
Профиль аллокаций для сортировки слиянием:

| ![image](https://github.com/user-attachments/assets/d3cf57f8-d069-4161-b4c4-4b3d1f5f6f53) |
|-|

На профиле заметны выделения памяти под целочисленные массивы в процессе выполнения метода ```MergeSubArrays```, что соответсвует ожиданиям при разработке реализации.


## Рекурсивная быстрая сортировка
### Реализация
Была создана реализация на основе стандартного рекурсивного алгоритма, дробящего полученный массив на две части, в первую из которых перемещаются элементы, меньшие чем эталонный (в качестве него в данной реализации выбирается первый элемент сортируемого подмассива), во вторую - остальные. После этого части массива сортируются рекурсивно. Ожидаемая (средневероятная) вычислительная сложность алгоритма определяется как $`O(n * log n)`$, при этом в худшем случае возможна квадратичная сложность. Худший случай возникает в том случае, когда для каждого вызова сортировки для подмассива размером $`n`$, после дробления в одной части оказывается один элемент, а в другой, соответственно, $`n - 1`$. Для предотвращения худшего случая используются разные модификации алгоритма, такие как рандомизация и более взвешанный выбор эталонного элемента.

### Гипотезы
- с учетом реализации алгоритма ожидается линейно-логарифмический рост времени выполнения сортировки при линейном росте объема сортируемых данных;
- рекурсивная реализация алгоритма позволяет ожидать большого количества вызовов ```QSortRecImpl``` на стеке, которые можно будет увидеть на CPU профиле;
- выполнение сортировки in-place позволяет ожидать того, что граф аллокаций будет пустым.
  
### Время работы
Результаты запуска бенчмарка JMH:

Data size | 1000 | 2000 | 4000 | 8000 | 16000 | 32000 | 64000 | 128000
--- | --- | --- | --- |--- |--- |--- |--- |---
Run duration, ms | 0,075 | 0,199 | 0,501 | 0,938 | 2,089 | 4,242 | 9,954 | 16,104
Error, ms | ± 0,005 | ± 0,011 | ± 0,084 | ± 0,045 | ± 0,141 | ± 0,217 | ± 2,035 | ± 2,814

Как видно из замеров, при удвоении размера исходного массива время работы с ним алгоритма в среднем удваивается. Логарифмическая составляющая сильнее заметна для массивов малого объема, поскольку на реальных данных, в отличие от теоретических моделей, логарифм принимает конкретное значение, являющееся очень малым по сравнению с линейной составляющей. Результаты замеров времени работы алгоритма на практике подтверждают гипотезу о линейно-логарифмичесом времени работы рекурсивной быстрой сортировки.

### CPU flamegraph
Профиль CPU для рекурсивной быстрой сортировки:

| ![image](https://github.com/user-attachments/assets/c6036b2a-52de-4f9c-ba81-4a1133b5077a) |
|-|

Как и ожидалось, на профиле вызовов при работе алгоритма отображаются рекурсивные вызовы метода ```QSortRecImpl```. Одноуровневые в контексте рекурсии вызовы при семплировании отображаются как один. Глубина рекурсии заметно выше, чем при сортировке слиянием. Это связано с неравномерным разбиением сортируемого подмассива в алгоритме быстрой сортировки.

### Allocation flamegraph
Профиль аллокаций для рекурсивной быстрой сортировки:

| ![image](https://github.com/user-attachments/assets/4987f7ee-4df1-4121-9fd1-10e58ee4074f) |
|-|

Как и ожидалось, при работе алгоритма не происходит заметных выделений памяти. 



## Итеративная быстрая сортировка
### Реализация
Отличием данной реализации от стандартной рекурсивной является трансформация рекурсивных вызовов в итеративное дробление и сортировку подмассивов. Трансформация осуществляется путем перемещения расходов на хранение контекстов рекурсий в поддерживаемый при работе алгоритма стэк, элементами которого являются границы подмассивов, ожидающих сортировки. Размеры подмассивов не являются фиксированными в силу неравномерности разбиений. 

### Гипотезы
- с учетом реализации алгоритма ожидается линейно-логарифмический рост времени выполнения сортировки при линейном росте объема сортируемых данных. Также, в связи с заменой рекурсивного алгоритма на итерационный, ожидается небольшое ускорение работы алгоритма;
- итеративная структура алгоритма позволяет ожидать минимального количества вызовов различных методов при его работе;
- с учетом использования в алгоритме стека для границ подмассивов ожидается, что на профиле аллокаций отобразится выделение памяти для его содержимого.
  
### Время работы
Результаты запуска бенчмарка JMH:

Data size | 1000 | 2000 | 4000 | 8000 | 16000 | 32000 | 64000 | 128000
--- | --- | --- | --- |--- |--- |--- |--- |---
Run duration, ms | 0,046 | 0,142 | 0,338 | 0,733 | 1,572 | 3,632 | 6,903 | 14,709
Error, ms | ± 0,002 | ± 0,015 | ± 0,032 | ± 0,044 | ± 0,093 | ± 0,611 | ± 0,400 | ± 0,597

Результаты запуска бенчмарка JMH для рекурсивной реализации (для сравнения):

Data size | 1000 | 2000 | 4000 | 8000 | 16000 | 32000 | 64000 | 128000
--- | --- | --- | --- |--- |--- |--- |--- |---
Run duration, ms | 0,075 | 0,199 | 0,501 | 0,938 | 2,089 | 4,242 | 9,954 | 16,104
Error, ms | ± 0,005 | ± 0,011 | ± 0,084 | ± 0,045 | ± 0,141 | ± 0,217 | ± 2,035 | ± 2,814

Как видно из замеров, при удвоении размера исходного массива время работы с ним алгоритма в среднем удваивается. Логарифмическая составляющая сильнее заметна для массивов малого объема, поскольку на реальных данных, в отличие от теоретических моделей, логарифм принимает конкретное значение, являющееся очень малым по сравнению с линейной составляющей. Результаты замеров времени работы алгоритма на практике подтверждают гипотезу о линейно-логарифмичесом времени работы рекурсивной быстрой сортировки. Также из замеров видно, что итеративная реализация действительно работает чуть быстрее рекурсивной.

### CPU flamegraph
Профиль CPU для итеративной быстрой сортировки:

| ![image](https://github.com/user-attachments/assets/be9b4b0e-8871-4d8a-b371-0216d78c3b79) |
|-|

На CPU профиле отображаются последовательные вызовы методов, осуществляющих извлечение и добавление элементов в стек.

### Allocation flamegraph
Профиль аллокаций для итеративной быстрой сортировки:

| ![image](https://github.com/user-attachments/assets/2b4ab5b7-37c9-40ab-88f9-585a649730fe) |
|-|

На профиле заметно выделение памяти под содержимое стэка с границами подмассивов, что соответсвует ожиданиям при разработке реализации.


## Встроенная сортировка
### Реализация
Для использования встроенной сортировки вызывается метод ```Arrays.sort```. 

### Гипотезы
- ожидается, что оптимизированная встроенная сортировка для примитивного типа будет работать в несколько раз быстрее собственных реализаций.
  
### Время работы
Результаты запуска бенчмарка JMH в сравнении с аналогичным для собственных реализаций:

Data size | 1000 | 2000 | 4000 | 8000 | 16000 | 32000 | 64000 | 128000
--- | --- | --- | --- |--- |--- |--- |--- |---
Встроенная, ms | 0,030 | 0,129 | 0,269 | 0,622 | 1,143 | 2,786 | 5,435 | 11,760
Пузырьковая, ms | 1,462 | 6,093 | 22,908 | 111,334 | 10⁻⁶ | 10⁻⁶ | 10⁻⁶ | 10⁻⁶
Слиянием, ms | 0,073 | 0,220 | 0,511 | 1,007 | 2,237 | 4,815 | 10,294 | 21,562
Рекурсивная быстрая, ms | 0,075 | 0,199 | 0,501 | 0,938 | 2,089 | 4,242 | 9,954 | 16,104
Итеративная быстрая, ms | 0,046 | 0,142 | 0,338 | 0,733 | 1,572 | 3,632 | 6,903 | 14,709

Результаты замеров времени работы алгоритма на практике подтверждают гипотезу о линейно-логарифмичесом времени работы рекурсивной быстрой сортировки. Также из замеров видно, что встроенная сортировка работает примерно в 1.3 раза быстрее итеративной быстрой сортировки и примерно в 2 раза быстрее остальных линейно-логарифмических реализаций.

### CPU flamegraph
Профиль CPU для встроенной сортировки:

| ![image](https://github.com/user-attachments/assets/776a7354-0036-48ae-bd7a-4a51d65b22b8) |
|-|

Как видно из стека вызовов, встроенная сортировка склонилась к использованию для предоставленных данных рекурсивной быстрой сортировки с двумя эталонными элементами.

### Allocation flamegraph
Профиль аллокаций для встроенной сортировки:

| ![image](https://github.com/user-attachments/assets/82d90a97-244b-4657-abf0-44f2079daf86) |
|-|

При работе алгоритма встроенной сортировки не происходит заметных выделений памяти. 


## Вывод
В процессе выполнения работы были реализованы, применены и проанализированы пять различных алгоритмов сортировки сравнениями. Анализ среднего времени выполнения, профилей CPU и профилей аллокаций позволил убедиться в верности или неверности предварительно выдвинутых гипотез о вычислительной сложности, структуре вызовов и задействовании памяти алгоритмами. Самую высокую среднюю скорость работы из линейно-логарифмических сортировок демонстрирует встроенная сортировка, обращавшаяся к алгоритму быстрой сортировки с двумя эталонными элементами. Следующими в плане производительности, несмотря на их квадратичную сложность в худшем случае, стали, соответственно, итеративная и рекурсивная реализация быстрой сортировки. Самой медленной из рассмотренных оказалась сортировка слиянием.  
